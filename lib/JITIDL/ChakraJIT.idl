//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

import "wtypes.idl";

// TODO: OOP JIT, how do we make this better?
const int VTABLE_COUNT = 40;
const int EQUIVALENT_TYPE_CACHE_SIZE_IDL = 8;

typedef struct TypeHandlerIDL
{
    boolean isObjectHeaderInlinedTypeHandler;
    boolean isLocked;

    unsigned short inlineSlotCapacity;
    unsigned short offsetOfInlineSlots;

    int slotCapacity;
} TypeHandlerIDL;

typedef struct TypeIDL
{
    unsigned char flags;
    boolean isShared;

    int typeId;

    __int3264 libAddr;
    __int3264 protoAddr;
    __int3264 entrypointAddr;
    __int3264 propertyCacheAddr;
    __int3264 addr;

    TypeHandlerIDL handler;
} TypeIDL;

typedef struct EquivalentTypeSetIDL
{
    boolean sortedAndDuplicatesRemoved;
    unsigned short count;
    [size_is(count)] TypeIDL ** types;
} EquivalentTypeSetIDL;

typedef struct FixedFieldIDL
{
    boolean nextHasSameFixedField;
    TypeIDL type;
    __int3264 fieldValue;
} FixedFieldIDL;

typedef struct JITTimeConstructorCacheIDL
{
    boolean skipNewScObject;
    boolean ctorHasNoExplicitReturnValue;
    boolean typeIsFinal;
    boolean isUsed;

    short inlineSlotCount;

    int slotCount;

    TypeIDL type;

    __int3264 runtimeCacheAddr;
    __int3264 runtimeCacheGuardAddr;
} JITTimeConstructorCacheIDL;

typedef struct ObjTypeSpecFldIDL
{
    // TODO: OOP JIT we may want to copy some of the data in these pointers
    unsigned short flags;
    unsigned short slotIndex;
    unsigned short fixedFieldCount;
    int propertyId;
    int typeId;
    unsigned int id;
    __int3264 protoObjectAddr;
    __int3264 propertyGuardValueAddr;
    EquivalentTypeSetIDL * typeSet;
    TypeIDL * initialType;
    JITTimeConstructorCacheIDL * ctorCache;
    [size_is(fixedFieldCount)] FixedFieldIDL * fixedFieldInfoArray;
} ObjTypeSpecFldIDL;

typedef struct BVUnitIDL
{
    unsigned __int3264 word;
} BVUnitIDL;

typedef struct BVFixedIDL
{
    unsigned int len;
    [size_is(len)] BVUnitIDL data[*];
} BVFixedIDL;

typedef struct CallSiteIDL
{
    unsigned short bitFields;
    unsigned short returnType;
    unsigned int ldFldInlineCacheId;
    unsigned int sourceId;
    unsigned int functionId;
} CallSiteIDL;

typedef struct ThisIDL
{
    unsigned short valueType;
    byte thisType;
} ThisIDL;

typedef struct FldIDL
{
    unsigned short valueType;
    byte flags;
    byte polymorphicInlineCacheUtilization;
} FldIDL;

typedef struct ArrayCallSiteIDL
{
    byte bits;
    unsigned int functionNumber;
    unsigned short callSiteNumber;
} ArrayCallSiteIDL;

typedef struct LdElemIDL
{
    unsigned short arrayType;
    unsigned short elemType;
    byte bits;
} LdElemIDL;

typedef struct StElemIDL
{
    unsigned short arrayType;
    byte bits;
} StElemIDL;

typedef struct ProfileDataIDL
{
    byte implicitCallFlags;

    int flags;

    ThisIDL thisData;

    BVFixedIDL * loopFlags;

    unsigned short profiledLdElemCount;
    [size_is(profiledLdElemCount)] LdElemIDL * ldElemData;

    unsigned short profiledStElemCount;
    [size_is(profiledStElemCount)] StElemIDL * stElemData;

    unsigned short profiledArrayCallSiteCount;
    [size_is(profiledArrayCallSiteCount)] ArrayCallSiteIDL * arrayCallSiteData;

    // TODO: michhol OOP JIT, share counts with body
    unsigned int inlineCacheCount;
    [size_is(inlineCacheCount)] FldIDL * fldData;

    unsigned short profiledSlotCount;
    [size_is(profiledSlotCount)] unsigned short * slotData;

    unsigned short profiledCallSiteCount;
    [size_is(profiledCallSiteCount)] CallSiteIDL * callSiteData;

    unsigned short profiledReturnTypeCount;
    [size_is(profiledReturnTypeCount)] unsigned short * returnTypeData;

    unsigned short profiledDivOrRemCount;
    [size_is(profiledDivOrRemCount)] unsigned short * divideTypeInfo;

    unsigned short profiledSwitchCount;
    [size_is(profiledSwitchCount)] unsigned short * switchTypeInfo;

    unsigned short profiledInParamsCount;
    [size_is(profiledInParamsCount)] unsigned short * parameterInfo;

    unsigned int loopCount;
    [size_is(loopCount)] byte * loopImplicitCallFlags;

    __int3264 arrayCallSiteDataAddr;
} ProfileDataIDL;

typedef struct ThreadContextDataIDL
{
    boolean isThreadBound;
    __int3264 processHandle;
    __int3264 chakraBaseAddress;
    __int3264 crtBaseAddress;
    __int3264 threadStackLimitAddr;
    __int3264 scriptStackLimit;
    __int3264 bailOutRegisterSaveSpace;
    __int3264 disableImplicitFlagsAddr;
    __int3264 implicitCallFlagsAddr;
    __int3264 debuggingFlagsAddr;
    __int3264 debugStepTypeAddr;
    __int3264 debugFrameAddressAddr;
    __int3264 debugScriptIdWhenSetAddr;
} ThreadContextDataIDL;

typedef struct ScriptContextDataIDL
{
    boolean isRecyclerVerifyEnabled;
    unsigned int recyclerVerifyPad;
    __int3264 vtableAddresses[VTABLE_COUNT];

    __int3264 nullAddr;
    __int3264 undefinedAddr;
    __int3264 trueAddr;
    __int3264 falseAddr;
    __int3264 undeclBlockVarAddr;
    __int3264 scriptContextAddr;
    __int3264 emptyStringAddr;
    __int3264 negativeZeroAddr;
    __int3264 numberTypeStaticAddr;
    __int3264 stringTypeStaticAddr;
    __int3264 objectTypeAddr;
    __int3264 objectHeaderInlinedTypeAddr;
    __int3264 regexTypeAddr;
    __int3264 arrayTypeAddr;
    __int3264 nativeIntArrayTypeAddr;
    __int3264 nativeFloatArrayTypeAddr;
    __int3264 arrayConstructorAddr;
    __int3264 charStringCacheAddr;
    __int3264 libraryAddr;
    __int3264 sideEffectsAddr;
    __int3264 arraySetElementFastPathVtableAddr;
    __int3264 intArraySetElementFastPathVtableAddr;
    __int3264 floatArraySetElementFastPathVtableAddr;
    __int3264 numberAllocatorAddr;
    __int3264 recyclerAddr;
    __int3264 builtinFunctionsBaseAddr;
} ScriptContextDataIDL;

typedef struct SmallSpanSequenceIDL
{
    int baseValue;
    unsigned int statementLength;
    [size_is(statementLength)] unsigned int * statementBuffer;
    unsigned int actualOffsetLength; // REVIEW: are lengths the same?
    [size_is(actualOffsetLength)] unsigned int * actualOffsetList;
} SmallSpanSequenceIDL;

typedef struct JITLoopHeaderIDL
{
    boolean isNested;
    boolean isInTry;
    unsigned int interpretCount;
    unsigned int startOffset;
    unsigned int endOffset;
} JITLoopHeaderIDL;

typedef struct AsmJsDataIDL
{
    boolean isHeapBufferConst;
    boolean usesHeapBuffer;
    unsigned short argByteSize;
    unsigned short argCount;
    [size_is(argCount)] byte * argTypeArray;
    int retType;
    int intConstCount;
    int doubleConstCount;
    int floatConstCount;
    int simdConstCount;
    int intTmpCount;
    int doubleTmpCount;
    int floatTmpCount;
    int simdTmpCount;
    int intVarCount;
    int doubleVarCount;
    int floatVarCount;
    int simdVarCount;
    int intByteOffset;
    int doubleByteOffset;
    int floatByteOffset;
    int simdByteOffset;
    int totalSizeInBytes;
} AsmJsDataIDL;

typedef struct FunctionJITRuntimeIDL
{
    unsigned int clonedCacheCount;
    [size_is(clonedCacheCount)] __int3264 * clonedInlineCaches;
} FunctionJITRuntimeIDL;

// FunctionBody fields, read only in JIT, gathered in foreground
typedef struct FunctionBodyDataIDL
{
    byte flags;

    // TODO: compress booleans into flags
    boolean doBackendArgumentsOptimization;
    boolean isLibraryCode;
    boolean isAsmJsMode;
    boolean hasImplicitArgIns;
    boolean isStrictMode;
    boolean isEval;
    boolean hasScopeObject;
    boolean hasCachedScopePropIds;
    boolean inlineCachesOnFunctionObject;
    boolean doInterruptProbe;
    boolean isGlobalFunc;
    boolean isInlineApplyDisabled;
    boolean doJITLoopBody;
    boolean disableInlineSpread;
    boolean hasNestedLoop;
    boolean hasNonBuiltInCallee;

    unsigned short envDepth;
    unsigned short inParamCount;
    unsigned short profiledIterations;
    unsigned short argUsedForBranch;
    unsigned short profiledCallSiteCount;

    unsigned int funcNumber;
    unsigned int sourceContextId;
    unsigned int nestedCount;
    unsigned int scopeSlotArraySize;
    unsigned int attributes;
    unsigned int byteCodeCount;
    unsigned int byteCodeInLoopCount;
    unsigned int nonLoadByteCodeCount;
    unsigned int localFrameDisplayReg;
    unsigned int localClosureReg;
    unsigned int envReg;
    unsigned int firstTmpReg;
    unsigned int firstInnerScopeReg;
    unsigned int varCount;
    unsigned int innerScopeCount;
    unsigned int thisRegisterForEventHandler;
    unsigned int funcExprScopeRegister;
    unsigned int loopCount;
    unsigned int recursiveCallSiteCount;
    unsigned int isInstInlineCacheCount; // TODO: only used in Assert

    SmallSpanSequenceIDL statementMap;

    unsigned int byteCodeLength;
    [size_is(byteCodeLength)] byte * byteCodeBuffer;

    unsigned int constCount;
    [size_is(constCount)] __int3264 * constTable;
    unsigned int constTypeCount;
    [size_is(constTypeCount)] int * constTypeTable;

    unsigned int inlineCacheCount;
    [size_is(inlineCacheCount)] int * cacheIdToPropertyIdMap;
    [size_is(inlineCacheCount)] __int3264 * inlineCaches;

    unsigned int loopHeaderArrayLength;
    [size_is(loopHeaderArrayLength)] JITLoopHeaderIDL * loopHeaders;

    unsigned int referencedPropertyIdCount;
    [size_is(referencedPropertyIdCount)] int * referencedPropertyIdMap;

    unsigned int nameLength;
    [size_is(nameLength)] wchar_t * displayName;

    unsigned int runtimeDataCount; // only needed for topfunc?
    [size_is(runtimeDataCount)] FunctionJITRuntimeIDL * profiledRuntimeData;

    ProfileDataIDL * profileData;

    AsmJsDataIDL * asmJsData;

    __int3264 loopHeaderArrayAddr;
    __int3264 functionBodyAddr;
    __int3264 scriptIdAddr;
    __int3264 probeCountAddr;
    __int3264 flagsAddr;
    __int3264 regAllocStoreCountAddr;
    __int3264 regAllocLoadCountAddr;
    __int3264 callCountStatsAddr;
    __int3264 nestedFuncArrayAddr;
    __int3264 auxArrayBufferAddr;
} FunctionBodyDataIDL;

// EntryPointInfo fields, read/write in JIT
typedef struct EntryPointInfoOutputIDL
{
    boolean hasJittedStackClosure;
    int localVarSlotsOffset; // FunctionEntryPointInfo only
    int localVarChangedOffset; // FunctionEntryPointInfo only
    unsigned int frameHeight;
} EntryPointInfoOutputIDL;

// FunctionBody fields, written to from JIT
typedef struct FunctionBodyOutputIDL
{
    boolean hasBailoutInstr;
    unsigned short argUsedForBranch;
} FunctionBodyOutputIDL;

typedef struct FunctionJITTimeDataIDL
{
    boolean isAggressiveInliningEnabled;
    boolean isInlined;
    unsigned int localFuncId;
    __int3264 functionInfoAddr;
    __int3264 callsCountAddress;
    __int3264 weakFuncRef;
    FunctionBodyDataIDL * bodyData; // TODO: oop jit, can these repeat, should we share?

    BVFixedIDL * inlineesBv;

    unsigned int sharedPropGuardCount;
    [size_is(sharedPropGuardCount)] int * sharedPropertyGuards;


    unsigned int globalObjTypeSpecFldInfoCount;
    [size_is(globalObjTypeSpecFldInfoCount)] ObjTypeSpecFldIDL ** globalObjTypeSpecFldInfoArray;

    unsigned int inlineeCount;
    [size_is(inlineeCount)] struct FunctionJITTimeDataIDL ** inlinees;
    unsigned int ldFldInlineeCount;
    [size_is(ldFldInlineeCount)] struct FunctionJITTimeDataIDL ** ldFldInlinees;

    unsigned int objTypeSpecFldInfoCount;
    [size_is(objTypeSpecFldInfoCount)] ObjTypeSpecFldIDL ** objTypeSpecFldInfoArray;

    struct FunctionJITTimeDataIDL * next;
} FunctionJITTimeDataIDL;

typedef struct XProcNumberPageSegment
{
    __int3264 pageAddress;
    __int3264 allocStartAddress;
    __int3264 allocEndAddress;
    __int3264 pageSegment;
    __int3264 chunkAllocator;
    struct XProcNumberPageSegment* nextSegment;
    unsigned int blockSize; // 2 pages
    unsigned int committedEnd;
    unsigned int pageCount; // REVIEW: don't actually need these two fields, they are constant
    unsigned int sizeCat;
    unsigned int blockIntegratedSize;
} XProcNumberPageSegment;

// CodeGenWorkItem fields, read only in JIT
typedef struct CodeGenWorkItemIDL
{
    boolean hasSharedPropGuards;
    boolean isJitInDebugMode;  // Whether JIT is in debug mode for this work item.
    byte type;
    char jitMode;

    unsigned int loopNumber;
    XProcNumberPageSegment xProcNumberPageSegment;

    FunctionJITTimeDataIDL * jitData;
    __int3264 nativeDataAddr;
} CodeGenWorkItemIDL;

typedef struct NativeDataFixupEntry
{
    struct NativeDataFixupEntry* next;
    unsigned int addrOffset;
    unsigned int targetTotalOffset;
} NativeDataFixupEntry;

typedef struct NativeDataFixupRecord
{
    unsigned int index;
    unsigned int length;
    unsigned int startOffset;
    struct NativeDataFixupEntry* updateList;
} NativeDataFixupRecord;

typedef struct NativeDataFixupTable
{
    unsigned int count;
    [size_is(count)] NativeDataFixupRecord fixupRecords[*];
} NativeDataFixupTable;


typedef struct TypeEquivalenceRecordIDL
{
    unsigned int propertyCount;
    unsigned int propertyOffset;
} TypeEquivalenceRecord;

typedef struct EquivlentTypeCacheIDL
{
    __int3264 types[EQUIVALENT_TYPE_CACHE_SIZE_IDL];
    __int3264 guardOffset;
    struct TypeEquivalenceRecordIDL record;
    unsigned int nextEvictionVictim;
    boolean isLoadedFromProto;
    boolean hasFixedValue;
} EquivlentTypeCacheIDL;

typedef struct EquivalentTypeGuardOffsets
{
    EquivlentTypeCacheIDL cache;
    unsigned int count;
    [size_is(count)] unsigned int offsets[*];

} EquivalentTypeGuardOffsets;

typedef struct NativeDataBuffer
{
    unsigned int len;
    unsigned int unused;
    [size_is(len)] byte data[*];

} NativeDataBuffer;

// Fields that JIT modifies
typedef struct JITOutputIDL
{
    boolean isInPrereservedRegion;

    unsigned short pdataCount;
    unsigned short xdataSize;

    EntryPointInfoOutputIDL writeableEPData;
    FunctionBodyOutputIDL writeableBodyData;

    unsigned int codeSize;

    NativeDataFixupTable* nativeDataFixupTable;
    NativeDataBuffer* buffer;
    EquivalentTypeGuardOffsets* equivalentTypeGuardOffsets;

    __int64 codeAddress;
    __int64 xdataAddr;

    XProcNumberPageSegment* numberPageSegments;
    
    unsigned int inlineeFrameOffsetArrayOffset;
    unsigned int inlineeFrameOffsetArrayCount;
} JITOutputIDL;

[
    uuid(ead694ed-2243-44cb-a9dc-85d3ba934dab),
    pointer_default(unique)
]
interface IChakraJIT
{
    HRESULT Shutdown([in] handle_t binding);

    HRESULT InitializeThreadContext(
        [in] handle_t binding,
        [in] ThreadContextDataIDL * threadData,
        [out] __int3264 * threadContextInfoAddress);

    HRESULT CleanupThreadContext(
        [in] handle_t binding,
        [in] __int3264 threadContextInfoAddress);

    HRESULT InitializeScriptContext(
        [in] handle_t binding,
        [in] ScriptContextDataIDL * scriptContextData,
        [out] __int3264 * scriptContextInfoAddress);

    HRESULT CleanupScriptContext(
        [in] handle_t binding,
        [in] __int3264 scriptContextInfoAddress);

    HRESULT FreeAllocation(
        [in] handle_t binding,
        [in] __int3264 threadContextInfoAddress,
        [in] __int3264 address);

    HRESULT RemoteCodeGen(
        [in] handle_t binding,
        [in] __int3264 threadContextInfoAddress,
        [in] __int3264 scriptContextInfoAddress,
        [in] CodeGenWorkItemIDL * workItemData,
        [out] JITOutputIDL * jitData);

}
